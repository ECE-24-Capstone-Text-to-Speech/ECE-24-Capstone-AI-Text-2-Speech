from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    Request,
    Response,
    UploadFile,
    status,
)
from typing import Union
import os
from fastapi.responses import FileResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
from internal.cookies import getCurrUser
from internal.getFile import (
    get_list_of_audio_in_temp,
    get_list_of_audio_in_tortoise_out,
)
from internal.saveFile import save_audio_to_temp

# from models.AudioFile import AudioUploadFile

from dependencies import get_token_header


import torch
import torchaudio
import torch.nn as nn
import torch.nn.functional as F
from tortoise_tts.tortoise.api import TextToSpeech
from tortoise_tts.tortoise.utils.audio import load_audio, load_voice, load_voices
import torchaudio
import IPython
##from tortoise_tts.calltortoise import generate_voice_tortoise

##generate_voice_tortoise("daniel", "Hello. This is Angie's second A.I. voice. Nice to meet you!")
MAX_FILE_SIZE = 1_000_000  # 1 MB


router = APIRouter(
    prefix="/files",  # all paths in this file assumes preceed by `/files`
    tags=["files"],
    # dependencies=[Depends(get_token_header)],
    responses={404: {"description": "files path needs functions name appended"}},
)

# router.mount("/files", StaticFiles(directory="temp"), name="audioFiles")


@router.get("/")
async def audio_page():
    content = """
        <body>
            <form action="/files/audioInput" enctype="multipart/form-data" method="post">
                <input name="audioFile" type="file">
                <input type="submit">
            </form>
        </body>
    """
    return HTMLResponse(content=content)


@router.post("/audioInput")
async def audio_input(request: Request, audioFile: UploadFile | None = None):
    """
    Grabs FormData.audioFile.
    Requires frontend to send file in as FormData, input called "audioFile"
    """
    user = getCurrUser(request)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Please log in order to upload or download files!",
        )

    if not audioFile:
        raise HTTPException(
            status_code=404, detail="No input audio file given in the request."
        )

    # Extract file extension from the filename
    file_extension = audioFile.filename.split(".")[-1].lower()

    # Check if the file extension is one of the allowed formats
    allowed_formats = {"mp3", "wav"}
    if file_extension not in allowed_formats:
        raise HTTPException(
            status_code=415,
            detail=f"File format not supported. Supported formats are MP3 and WAV. File extension provided is: {file_extension}",
        )

    # Check file size
    if audioFile.size > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=413,
            detail=f"File size = {audioFile.size:,} bytes, exceeds the limit of {MAX_FILE_SIZE:,} bytes by {(audioFile.size-MAX_FILE_SIZE):,} bytes.",
        )

    # Reset the file cursor to the beginning
    audioFile.file.seek(0)

    fileName = audioFile.filename

    message: str = "Default message"
    saved: bool = False

    # Check if the file already exists in the temporary directory
    if fileName not in await get_list_of_audio_in_temp(user=user):
        saved, message = await save_audio_to_temp(audioFile, user=user)
    else:
        message = "File already exists"

    return {
        "filename": fileName,
        "format": file_extension,
        "success": saved,
        "message": message,
    }


@router.get("/download")
async def download_file(request: Request):
    user = getCurrUser(request)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Please log in order to upload or download files!",
        )
    files = await get_list_of_audio_in_tortoise_out()
    print("awooga")
    await start_tortoise()
    print("done")
    for file in files:
        return FileResponse(path=file)
    else:
        raise HTTPException(status_code=404, detail="File not found")


@router.get("/audios")
async def get_audio_list():
    audioList = await get_list_of_audio_in_temp()
    print(audioList)
    print("awooga")
    await start_tortoise()
    print("done")
    return audioList


@router.get(
    "/audios/{audio_name}",
    # Set what the media type will be in the autogenerated OpenAPI specification.
    # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
    responses={
        200: {"content": {"multipart/form-data": {}}},
        404: {"detail": "File not found"},
    },
    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=FileResponse,
)
async def get_audio_file(request: Request, audio_name: str):
    # audio_bytes: str|None = await fetch_audio_from_temp(audio_name)
    # user = getCurrUser(request)
    # if not user:
    #     raise HTTPException(
    #         status_code=status.HTTP_401_UNAUTHORIZED,
    #         detail="Please log in order to upload or download files!",
    #     )
    files = await get_list_of_audio_in_temp(fullPath=True)
    for file in files:
        if audio_name == file.split("/")[-1]:
            return FileResponse(path=file)
    else:
        raise HTTPException(status_code=404, detail="File not found")
    

# This will download all the models used by Tortoise from the HF hub.
# tts = TextToSpeech()
# If you want to use deepspeed the pass use_deepspeed=True nearly 2x faster than normal



async def start_tortoise():
    print("work")
    tts = TextToSpeech()
    # Save the uploatts = TextToSpeech(use_deepspeed=True, kv_cache=True)

# This is the text that will be spoken.
    
    text = "Thanks for reading this article. I hope you learned something." ##change to a frontend input
    

# Pick a "preset mode" to determine quality. Options: {"ultra_fast", "fast" (default), "standard", "high_quality"}. See docs in api.py
    preset = "ultra_fast"

# Optionally, upload use your own voice by running the next two cells. I recommend
# you upload at least 2 audio clips. They must be a WAV file, 6-10 seconds long.

    CUSTOM_VOICE_NAME = "john"     ##go through custom voices and optimize this line. There's a bunch in tortoise/voices/
    custom_voice_folder = f"temp/{CUSTOM_VOICE_NAME}"

    # Save the uploaded files
    file1_path = os.path.join(custom_voice_folder, "temp/john/1.wav")
    file2_path = os.path.join(custom_voice_folder, "temp/john/2.wav")

    ##with open(file1_path, 'wb') as f:
    ##    f.write(1.wav.file.read())

    ##with open(file2_path, 'wb') as f:
    ##   f.write(audioFile2.file.read())
    # Load the custom voice for Tortoise. # Generate speech with the custom voice.
    print(f"Started Training on {file1_path} and {file2_path}")
    ##needs to add a folder to tortoise_tts/tortoise/voices.
    ##for example the john folder is tortoise_tts/tortoise/voices/john, idk how to get load_voice to work without
    #this folder
    voice_samples, conditioning_latents = load_voice(CUSTOM_VOICE_NAME) ##change

    # Generate speech with the custom voice
    gen = tts.tts_with_preset(text, voice_samples=voice_samples, conditioning_latents=conditioning_latents, preset='fast')
    print("Finished generation of user voice")
    # Save the generated speech
    generated_path = f'generated-{CUSTOM_VOICE_NAME}.wav'
    torchaudio.save(f'generated-{CUSTOM_VOICE_NAME}.wav', gen.squeeze(0).cpu(), 24000)

    # Optionally, return the generated speech file to the client
    IPython.display.Audio(f'generated-{CUSTOM_VOICE_NAME}.wav')
    return FileResponse(generated_path, media_type="audio/wav", filename=generated_path)